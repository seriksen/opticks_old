g4codegen_review
===================

The g4codegen creates strings of G4VSolid creating 
code from instances of G4VSolid. This is convenient
when operating from GDML, as can generate tests of all 
solids in a consistent/automated way.


::

    opticks-find g4code


extg4/X4PhysicalVolume::
     
    438 GMesh* X4PhysicalVolume::convertSolid( int lvIdx, int soIdx, const G4VSolid* const solid, const std::string& lvname) const
    439 {
    440      nnode* raw = X4Solid::Convert(solid)  ;
    441      if(m_g4codegen)
    442      {
    443          raw->dump_g4code();   // just for debug 
    444          X4CSG::GenerateTest( solid, m_g4codegendir , lvIdx ) ;
    445      }

npy/NNode::

     498 void nnode::dump_g4code() const
     499 {
     500     std::ostream& out = std::cout ;
     501     to_g4code( this, out, 0);
     502 }
     503 void nnode::write_g4code(const char* path_) const
     504 {
     505     std::string path = BFile::FormPath(path_) ;
     506     std::ofstream out(path.c_str());
     507     to_g4code( this, out, 0 );
     508 }
     509 
     510 void nnode::to_g4code(const nnode* root, std::ostream& out, unsigned depth )   // static
     511 {
     512     out << "// start portion generated by nnode::to_g4code " << std::endl ;
     513     out << "G4VSolid* make_solid()" << std::endl ;
     514     out << "{ " << std::endl ;
     515 
     516     to_g4code_r( root, out, 0 );
     517 
     518     out << "   return a ; " << std::endl ;
     519     out << "} " << std::endl ;
     520     out << "// end portion generated by nnode::to_g4code " << std::endl ;
     521 }

postorder visit streaming the g4code of every node::

     523 void nnode::to_g4code_r(const nnode* node, std::ostream& out, unsigned depth )  // static
     524 {
     525     if(node->left && node->right)
     526     {
     527         // hmm : this doesnt follow for polycone, as its an nnode union tree, but a primitive in G4 
     528         //assert( node->left->g4code && node->right->g4code );
     529         if( node->left->g4code && node->right->g4code )
     530         {
     531             to_g4code_r( node->left, out, depth+1 ) ;
     532             to_g4code_r( node->right, out, depth+1 ) ;
     533         }
     534         else
     535         {
     536             LOG(error) << "no g4code on left/right :  prim in G4, but tree in Opticks perhaps ? " ;
     537         }
     538     }
     539     assert( node->g4code );
     540     out << "    " << node->g4code
     541         << " // " << depth
     542         << std::endl ;
     543 }

::

    203 void X4CSG::generateTestMain( std::ostream& out ) const
    204 {
    205     out << HEAD ;
    206     nnode::to_g4code(nsolid, out,  0 ) ;
    207     out << TAIL ;
    208 }



All the solid conversions have setG4Param, and thats 
all thats needed for simple cases.  When need to create 
other objects and refer to them (eg for booleans or polycones):

1. identifiers are formed and collected into paramter vectors
2. other object g4code are added with addG4Code
3. the lines are wrapped up with setG4Param.

For example::

     217 void X4Solid::convertBooleanSolid()
     218 { 
     ...
     260     std::vector<std::string> param ;
     261     param.push_back( xleft->getIdentifier() );
     262 
     263     if(is_right_displaced)
     264     {
     265         X4Solid* xright_displaced = xright->getDisplaced() ;
     266 
     267         //assert(b->gtransform) ; 
     268         const G4DisplacedSolid* const disp = static_cast<const G4DisplacedSolid*>(right);
     269         assert( disp );
     270         X4AffineTransform xdirect(disp->GetDirectTransform());
     271 
     272         const char* rot_id = OTHER_ID->get(false) ;
     273         const char* tla_id = OTHER_ID->get(false) ;
     274 
     275         // TODO: suppress identity 
     276         std::string rot = xdirect.getRotationCode(rot_id);
     277         std::string tla = xdirect.getTranslationCode(tla_id);
     278 
     279         addG4Code(rot.c_str()) ;
     280         addG4Code(tla.c_str()) ;
     281 
     282         param.push_back( xright_displaced->getIdentifier() );
     283         param.push_back( rot_id ) ;
     284         param.push_back( tla_id ) ;
     285     }
     286     else
     287     {
     288         param.push_back( xright->getIdentifier() );
     289     }
     290 
     291 
     292     setG4Param(param);
     293 }


::

    241 void X4SolidBase::addG4Code( const char* g4code )
    242 {
    243     m_g4code.push_back(g4code);
    244 }
    245 
    246 void X4SolidBase::setG4Code( const char* g4code )
    247 {
    248     assert( m_root && "must setG4Code after setRoot " );
    249     if(m_g4code.size() == 0 )
    250     {
    251         m_root->g4code = strdup(g4code) ;
    252     }
    253     else
    254     {
    255         addG4Code(g4code);
    256         std::stringstream ss ;
    257         for( unsigned i=0 ; i < m_g4code.size() ; i++) ss << m_g4code[i] << std::endl ;
    258         std::string concat = ss.str();
    259         m_root->g4code = strdup(concat.c_str()) ;
    260     }
    261     //LOG(info) << " root.g4code " << m_root->g4code ; 
    262 }

