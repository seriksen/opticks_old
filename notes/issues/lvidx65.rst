lvidx 65 : two box cuts from segmented ring  : SstBotCirRibBase0xc26e2d0
===========================================================================

* ~/opticks_refs/lvidx65_box_cuts_do_little.png

* unclear cause of bbox diff 
* needs nsegmentphi to avoid living unbalanced


::

    op --dlv65 --gltf 3

    8 segments in an ring with box cuts making the gaps


::

       377.713               SstBotCirRibBase0xc26e2d0 lvidx  65 nsp    204        intersection difference cylinder slab box3   nds[ 16]  4440 4441 4442 4443 4444 4445 4446 4447 6100 6101 ... 
       377.713               SstBotCirRibBase0xc26e2d0 lvidx  65 nsp    204 

        amn (   1400.071   390.181  -215.000) 
        bmn (   1407.720    12.467  -215.000) 
        dmn (     -7.649   377.713     0.000) 

        amx (   1961.571  1414.214   215.000) 
        bmx (   1998.360  1404.240   215.000) 
        dmx (    -36.789     9.974     0.000)



Possibibly a coincidence between box 

::

                       \
                        \
                         \
                          |
            +             |       -> X


CSG
----

::

    080 # generated by tboolean.py : 20170708-1036 
     81 # opticks-;opticks-tbool 65 
     82 # opticks-;opticks-tbool-vi 65 
     83 
     84 
     85 a = CSG("cylinder", param = [0.000,0.000,0.000,2000.000],param1 = [-215.000,215.000,0.000,0.000])
     86 b = CSG("cylinder", param = [0.000,0.000,0.000,1980.000],param1 = [-217.150,217.150,0.000,0.000])
     87 ab = CSG("difference", left=a, right=b)
     88 
     89 c = CSG("slab", param = [0.000,1.000,0.000,0.000],param1 = [0.000,2001.000,0.000,0.000])
     90 abc = CSG("intersection", left=ab, right=c)
     91 
     92 d = CSG("slab", param = [0.707,-0.707,0.000,0.000],param1 = [0.000,2001.000,0.000,0.000])
     93 abcd = CSG("intersection", left=abc, right=d)
     94 
     95 e = CSG("box3", param = [2020.000,25.000,440.000,0.000],param1 = [0.000,0.000,0.000,0.000])
     96 e.transform = [[1.000,0.000,0.000,0.000],[0.000,1.000,0.000,0.000],[0.000,0.000,1.000,0.000],[1255.000,0.000,0.000,1.000]]
     97 abcde = CSG("union", left=abcd, right=e)

    ///   x 
    In [1]: (-1010+1255,1010+1255)
    Out[1]: (245, 2265)
    ///   y


     98 
     99 f = CSG("box3", param = [2020.000,25.000,440.000,0.000],param1 = [0.000,0.000,0.000,0.000])
    100 f.transform = [[0.707,-0.707,0.000,0.000],[0.707,0.707,0.000,0.000],[0.000,0.000,1.000,0.000],[887.419,887.419,0.000,1.000]]
    101 abcdef = CSG("union", left=abcde, right=f)
    102 
    103 
    ###   difference changed to union  
    104 
    105 raw = abcdef
    106 
    107 raw.dump("raw")
    108 
    109 maxcsgheight = 4
    110 maxcsgheight2 = 5
    111 obj = Sc.optimize_csg(raw, maxcsgheight, maxcsgheight2 ) 
    112 
    113 obj.dump("optimized")
    114 
    115 uobj = raw
    116 


GDML
------

::

     1020     <tube aunit="deg" deltaphi="45" lunit="mm" name="SstBotCirRibPri0xc26d4e0" rmax="2000" rmin="1980" startphi="0" z="430"/>
     1021     <box lunit="mm" name="SstBotRibBase00xc0d1e90" x="2020" y="25" z="440"/>

     1022     <subtraction name="SstBotCirRibPri-ChildForSstBotCirRibBase0xc26e0a0">
     1023       <first ref="SstBotCirRibPri0xc26d4e0"/>
     1024       <second ref="SstBotRibBase00xc0d1e90"/>
     1025       <position name="SstBotCirRibPri-ChildForSstBotCirRibBase0xc26e0a0_pos" unit="mm" x="1255" y="0" z="0"/>
     1026     </subtraction>

     1027     <box lunit="mm" name="SstBotRibBase10xbfa4950" x="2020" y="25" z="440"/>

     1028     <subtraction name="SstBotCirRibBase0xc26e2d0">
     1029       <first ref="SstBotCirRibPri-ChildForSstBotCirRibBase0xc26e0a0"/>
     1030       <second ref="SstBotRibBase10xbfa4950"/>
     1031       <position name="SstBotCirRibBase0xc26e2d0_pos" unit="mm" x="887.419010389117" y="887.419010389117" z="0"/>
     1032       <rotation name="SstBotCirRibBase0xc26e2d0_rot" unit="deg" x="0" y="0" z="45"/>
     1033     </subtraction>




::

    delta:opticks_refs blyth$ opticks-;opticks-tbool- 65
    opticks-tbool- : sourcing /usr/local/opticks/opticksdata/export/DayaBay_VGDX_20140414-1300/extras/65/tbool65.bash
    args: 
    [2017-07-08 11:09:25,699] p8578 {/Users/blyth/opticks/analytic/csg.py:822} INFO - raw name:union
    un(un(in(in(di(cy,cy),sl),sl),bo),bo) height:5 totnodes:63 

                                        un abcdef    
                                un abcde         bo f
                        in abcd         bo e        
                in abc         sl d                
        di ab         sl c                        
    cy a     cy b                                
    [2017-07-08 11:09:25,700] p8578 {/Users/blyth/opticks/analytic/treebuilder.py:34} WARNING - balancing trees of this structure not implemented

    // this was because switched diff to union to see the sub-objects

    [2017-07-08 11:09:25,700] p8578 {/Users/blyth/opticks/analytic/csg.py:822} INFO - optimized name:union
    un(un(in(in(in(cy,!cy),sl),sl),bo),bo) height:5 totnodes:63 

                                        un abcdef    
                                un abcde         bo f
                        in abcd         bo e        
                in abc         sl d                
        in ab         sl c                        
    cy a     !cy b                                
    [2017-07-08 11:09:25,701] p8578 {/Users/blyth/opticks/analytic/csg.py:417} INFO - CSG.Serialize : writing 2 trees to directory /tmp/blyth/opticks/tbool/65 
    analytic=1_csgpath=/tmp/blyth/opticks/tbool/65_name=65_mode=PyCsgInBox
    delta:opticks_refs blyth$ 



::

     11 class TreeBuilder(object):
     12     @classmethod
     13     def balance(cls, tree):
     14         """
     15         Note that positivization is done inplace whereas
     16         the balanced tree is created separately 
     17         """
     18         if not tree.is_positive_form():
     19             log.fatal("cannot balance tree that is not in positive form")
     20             assert 0
     21         pass
     22         ops = tree.operators_()
     23         hops = tree.operators_(minsubdepth=2)   # operators above the bileaf operators  
     24 
     25         if len(ops) == 1:
     26             op = ops[0]
     27             prims = tree.primitives()
     28             balanced = cls.commontree(op, prims, tree.name+"_prim_balanced" )
     29         elif len(hops) == 1:
     30             op = hops[0]
     31             bileafs = tree.subtrees_(subdepth=1)
     32             balanced = cls.bileaftree(op, bileafs, tree.name+"_bileaf_balanced" )
     33         else:
     34             log.warning("balancing trees of this structure not implemented")
     35             balanced = tree
     36         pass
     37         return balanced




