#include "X4Solid.hh"

#include "G4Sphere.hh"
#include "G4BooleanSolid.hh"
#include "G4IntersectionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"

#include "G4SystemOfUnits.hh"


#include "NNode.hpp"

#include "PLOG.hh"

X4Solid::X4Solid(const G4VSolid* solid )
   :
   X4SolidBase(solid)
{
   init(); 
}

void X4Solid::init()
{
   switch( m_entityType )
   {
    // generated by x4-case- Mon Jun 11 20:16:46 HKT 2018 
    case _G4BooleanSolid      : convertBooleanSolid()          ; break ; 
    case _G4MultiUnion        : convertMultiUnion()            ; break ; 
    case _G4Box               : convertBox()                   ; break ; 
    case _G4Cons              : convertCons()                  ; break ; 
    case _G4EllipticalCone    : convertEllipticalCone()        ; break ; 
    case _G4Ellipsoid         : convertEllipsoid()             ; break ; 
    case _G4EllipticalTube    : convertEllipticalTube()        ; break ; 
    case _G4ExtrudedSolid     : convertExtrudedSolid()         ; break ; 
    case _G4Hype              : convertHype()                  ; break ; 
    case _G4Orb               : convertOrb()                   ; break ; 
    case _G4Para              : convertPara()                  ; break ; 
    case _G4Paraboloid        : convertParaboloid()            ; break ; 
    case _G4Polycone          : convertPolycone()              ; break ; 
    case _G4GenericPolycone   : convertGenericPolycone()       ; break ; 
    case _G4Polyhedra         : convertPolyhedra()             ; break ; 
    case _G4Sphere            : convertSphere()                ; break ; 
    case _G4TessellatedSolid  : convertTessellatedSolid()      ; break ; 
    case _G4Tet               : convertTet()                   ; break ; 
    case _G4Torus             : convertTorus()                 ; break ; 
    case _G4GenericTrap       : convertGenericTrap()           ; break ; 
    case _G4Trap              : convertTrap()                  ; break ; 
    case _G4Trd               : convertTrd()                   ; break ; 
    case _G4Tubs              : convertTubs()                  ; break ; 
    case _G4CutTubs           : convertCutTubs()               ; break ; 
    case _G4TwistedBox        : convertTwistedBox()            ; break ; 
    case _G4TwistedTrap       : convertTwistedTrap()           ; break ; 
    case _G4TwistedTrd        : convertTwistedTrd()            ; break ; 
    case _G4TwistedTubs       : convertTwistedTubs()           ; break ; 
   } 
}


G4ThreeVector X4Solid::GetAngles(const G4RotationMatrix& mtx)
{
   // from G4GDMLWriteDefine::GetAngles

   G4double x,y,z;
   G4RotationMatrix mat = mtx;
   mat.rectify();   // Rectify matrix from possible roundoff errors

   // Direction of rotation given by left-hand rule; clockwise rotation

   static const G4double kMatrixPrecision = 10E-10;
   const G4double cosb = std::sqrt(mtx.xx()*mtx.xx()+mtx.yx()*mtx.yx());

   if (cosb > kMatrixPrecision)
   {   
      x = std::atan2(mtx.zy(),mtx.zz());
      y = std::atan2(-mtx.zx(),cosb);
      z = std::atan2(mtx.yx(),mtx.xx());
   }   
   else
   {   
      x = std::atan2(-mtx.yz(),mtx.yy());
      y = std::atan2(-mtx.zx(),cosb);
      z = 0.0;
   }   

   return G4ThreeVector(x,y,z);
}

void X4Solid::booleanDisplacement( G4VSolid** pp, G4ThreeVector& pos, G4ThreeVector& rot )
{
    // cf /usr/local/opticks/externals/g4/geant4_10_02_p01/source/persistency/gdml/src/G4GDMLWriteSolids.cc
    int displaced = 0 ; 
    while (true)
    {  
      assert( displaced <= 8 );
      if (G4DisplacedSolid* disp = dynamic_cast<G4DisplacedSolid*>(*pp))
      {  
         pos += disp->GetObjectTranslation();
         rot += GetAngles(disp->GetObjectRotation());
         *pp = disp->GetConstituentMovedSolid();
         displaced++;
         continue;
      }
      break;
   }
}

void X4Solid::convertBooleanSolid()
{  
    const G4BooleanSolid* const solid = static_cast<const G4BooleanSolid*>(m_solid);
    assert(solid); 

    typedef enum { _intersection, _subtraction, _union, _error } Boolean_t ;     
    Boolean_t _operator = _error ;  
    if      (dynamic_cast<const G4IntersectionSolid*>(solid)) _operator = _intersection ;
    else if (dynamic_cast<const G4SubtractionSolid*>(solid))  _operator = _subtraction ;
    else if (dynamic_cast<const G4UnionSolid*>(solid))        _operator = _union ;
    assert( _operator != _error ) ;

    G4VSolid* left  = const_cast<G4VSolid*>(solid->GetConstituentSolid(0));
    G4VSolid* right = const_cast<G4VSolid*>(solid->GetConstituentSolid(1));

/* 
    TODO: get displacements operational

    G4ThreeVector left_pos,left_rot ;
    booleanDisplacement( &left, left_pos, left_rot );

    G4ThreeVector right_pos,right_rot;
    booleanDisplacement( &right, right_pos, right_rot );
*/

    X4Solid* xleft = new X4Solid(left); 
    X4Solid* xright = new X4Solid(right); 

    nnode* a = xleft->root(); 
    nnode* b = xright->root(); 

    nnode* n = NULL ; 
    switch(_operator)
    {
        case _intersection : { nintersection*  i = new nintersection(make_intersection( a, b )) ; n = (nnode*)i ; break ; } 
        case _union        : { nunion*         u = new nunion(make_union( a, b ))               ; n = (nnode*)u ; break ; }
        case _subtraction  : { ndifference*    d = new ndifference(make_difference( a, b ))     ; n = (nnode*)d ; break ; }
        default            : { assert(0) ; break ; } 
    }
    setRoot(n); 
}



void X4Solid::convertSphere()
{  
    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    //const G4String& name = GenerateName(sphere->GetName(),sphere);
    const G4String& name = solid->GetName();   
    // hmm pointer name or not ?  probably NO as its a live conversion 
    // (not via file) from one pointer to another : are not using 
    // the name as a "pointer" reference 

    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ; 
    float startphi = solid->GetStartPhiAngle()/degree ; 
    float deltaphi = solid->GetDeltaPhiAngle()/degree ; 
    float starttheta = solid->GetStartThetaAngle()/degree ; 
    float deltatheta = solid->GetDeltaThetaAngle()/degree ; 
   
    // see analytic/gdml.py yields different 
    // nnode subclasses (sometimes a little tree, sometimes a primitive) 
    // depending on parameter values 
    //
    //    nsphere 
    //    nzsphere 
    //        zsliced
    //    ndifference  
    //        handling rmin > 0 
    //    nintersection  
    //        when applying a segment
    //

    nnode* n = NULL ; 
    setRoot(n); 
}


