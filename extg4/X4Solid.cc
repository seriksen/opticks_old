
#include <iterator>
#include <algorithm>

#include "G4Hype.hh"
#include "G4Polycone.hh"
#include "G4Ellipsoid.hh"
#include "G4Torus.hh"
#include "G4Cons.hh"
#include "G4Trd.hh"
#include "G4Tubs.hh"
#include "G4Box.hh"
#include "G4Orb.hh"
#include "G4Sphere.hh"
#include "G4BooleanSolid.hh"
#include "G4IntersectionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"
#include "G4SystemOfUnits.hh"

#include "X4Solid.hh"
#include "BStr.hh"

#include "GLMFormat.hpp"
#include "NGLMExt.hpp"
#include "NGLM.hpp"
#include "NHyperboloid.hpp"
#include "NTorus.hpp"
#include "NCone.hpp"
#include "NConvexPolyhedron.hpp"
#include "NCylinder.hpp"
#include "NZSphere.hpp"
#include "NSphere.hpp"
#include "NBox.hpp"
#include "NNode.hpp"
#include "NTreeBuilder.hpp"

#include "PLOG.hh"


nnode* X4Solid::Convert(const G4VSolid* solid)
{
    X4Solid xs(solid);
    return xs.root(); 
}

X4Solid::X4Solid(const G4VSolid* solid )
   :
   X4SolidBase(solid)
{
   init(); 
}

void X4Solid::init()
{
   LOG(info) << desc();
   switch( m_entityType )
   {
    // generated by x4-case- Tue Jun 19 22:28:05 HKT 2018 
    case _G4DisplacedSolid    : convertDisplacedSolid()        ; break ; 
    case _G4UnionSolid        : convertUnionSolid()            ; break ; 
    case _G4IntersectionSolid : convertIntersectionSolid()     ; break ; 
    case _G4SubtractionSolid  : convertSubtractionSolid()      ; break ; 
    case _G4MultiUnion        : convertMultiUnion()            ; break ; 
    case _G4Box               : convertBox()                   ; break ; 
    case _G4Cons              : convertCons()                  ; break ; 
    case _G4EllipticalCone    : convertEllipticalCone()        ; break ; 
    case _G4Ellipsoid         : convertEllipsoid()             ; break ; 
    case _G4EllipticalTube    : convertEllipticalTube()        ; break ; 
    case _G4ExtrudedSolid     : convertExtrudedSolid()         ; break ; 
    case _G4Hype              : convertHype()                  ; break ; 
    case _G4Orb               : convertOrb()                   ; break ; 
    case _G4Para              : convertPara()                  ; break ; 
    case _G4Paraboloid        : convertParaboloid()            ; break ; 
    case _G4Polycone          : convertPolycone()              ; break ; 
    case _G4GenericPolycone   : convertGenericPolycone()       ; break ; 
    case _G4Polyhedra         : convertPolyhedra()             ; break ; 
    case _G4Sphere            : convertSphere()                ; break ; 
    case _G4TessellatedSolid  : convertTessellatedSolid()      ; break ; 
    case _G4Tet               : convertTet()                   ; break ; 
    case _G4Torus             : convertTorus()                 ; break ; 
    case _G4GenericTrap       : convertGenericTrap()           ; break ; 
    case _G4Trap              : convertTrap()                  ; break ; 
    case _G4Trd               : convertTrd()                   ; break ; 
    case _G4Tubs              : convertTubs()                  ; break ; 
    case _G4CutTubs           : convertCutTubs()               ; break ; 
    case _G4TwistedBox        : convertTwistedBox()            ; break ; 
    case _G4TwistedTrap       : convertTwistedTrap()           ; break ; 
    case _G4TwistedTrd        : convertTwistedTrd()            ; break ; 
    case _G4TwistedTubs       : convertTwistedTubs()           ; break ; 
   } 
}


G4ThreeVector X4Solid::GetAngles(const G4RotationMatrix& mtx)
{
   // from G4GDMLWriteDefine::GetAngles

   G4double x,y,z;
   G4RotationMatrix mat = mtx;
   mat.rectify();   // Rectify matrix from possible roundoff errors

   // Direction of rotation given by left-hand rule; clockwise rotation

   static const G4double kMatrixPrecision = 10E-10;
   const G4double cosb = std::sqrt(mtx.xx()*mtx.xx()+mtx.yx()*mtx.yx());

   if (cosb > kMatrixPrecision)
   {   
      x = std::atan2(mtx.zy(),mtx.zz());
      y = std::atan2(-mtx.zx(),cosb);
      z = std::atan2(mtx.yx(),mtx.xx());
   }   
   else
   {   
      x = std::atan2(-mtx.yz(),mtx.yy());
      y = std::atan2(-mtx.zx(),cosb);
      z = 0.0;
   }   

   return G4ThreeVector(x,y,z);
}

void X4Solid::booleanDisplacement( G4VSolid** pp, G4ThreeVector& pos, G4ThreeVector& rot )
{
    // cf /usr/local/opticks/externals/g4/geant4_10_02_p01/source/persistency/gdml/src/G4GDMLWriteSolids.cc
    int displaced = 0 ; 
    while (true)
    {  
      assert( displaced <= 8 );
      if (G4DisplacedSolid* disp = dynamic_cast<G4DisplacedSolid*>(*pp))
      {  
         pos += disp->GetObjectTranslation();
         rot += GetAngles(disp->GetObjectRotation());
         *pp = disp->GetConstituentMovedSolid();
         displaced++;
         continue;
      }
      break;
   }
}


void X4Solid::convertUnionSolid()
{
    convertBooleanSolid() ;
}
void X4Solid::convertIntersectionSolid()
{
    convertBooleanSolid() ;
}
void X4Solid::convertSubtractionSolid()
{
    convertBooleanSolid() ;
}
void X4Solid::convertDisplacedSolid()
{
    const G4DisplacedSolid* const solid = static_cast<const G4DisplacedSolid*>(m_solid);
    G4VSolid* moved = solid->GetConstituentMovedSolid() ;

    X4Solid* xmoved = new X4Solid(moved);
    nnode* a = xmoved->root();

    // just ignoring the displacment for now

    setRoot(a); 
}

void X4Solid::convertBooleanSolid()
{  
    const G4BooleanSolid* const solid = static_cast<const G4BooleanSolid*>(m_solid);
    assert(solid); 

    typedef enum { _intersection, _subtraction, _union, _error } Boolean_t ;     
    Boolean_t _operator = _error ;  
    if      (dynamic_cast<const G4IntersectionSolid*>(solid)) _operator = _intersection ;
    else if (dynamic_cast<const G4SubtractionSolid*>(solid))  _operator = _subtraction ;
    else if (dynamic_cast<const G4UnionSolid*>(solid))        _operator = _union ;
    assert( _operator != _error ) ;

    G4VSolid* left  = const_cast<G4VSolid*>(solid->GetConstituentSolid(0));
    G4VSolid* right = const_cast<G4VSolid*>(solid->GetConstituentSolid(1));

/* 
    TODO: get displacements operational

    G4ThreeVector left_pos,left_rot ;
    booleanDisplacement( &left, left_pos, left_rot );

    G4ThreeVector right_pos,right_rot;
    booleanDisplacement( &right, right_pos, right_rot );
*/

    X4Solid* xleft = new X4Solid(left); 
    X4Solid* xright = new X4Solid(right); 

    nnode* a = xleft->root(); 
    nnode* b = xright->root(); 

    nnode* n = NULL ; 
    switch(_operator)
    {
        case _intersection : { nintersection*  i = new nintersection(make_intersection( a, b )) ; n = (nnode*)i ; break ; } 
        case _union        : { nunion*         u = new nunion(make_union( a, b ))               ; n = (nnode*)u ; break ; }
        case _subtraction  : { ndifference*    d = new ndifference(make_difference( a, b ))     ; n = (nnode*)d ; break ; }
        default            : { assert(0) ; break ; } 
    }
    setRoot(n); 
}




nnode* X4Solid::convertSphere_(bool only_inner)
{
    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);

    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ; 

    bool has_inner = !only_inner && rmin > 0.f ; 
    nnode* inner = has_inner ? convertSphere_(true) : NULL ;  
    float radius = only_inner ? rmin : rmax ;   

    LOG(info) 
              << " radius : " << radius 
              << " only_inner : " << only_inner
              << " has_inner : " << has_inner 
              ;

    float startThetaAngle = solid->GetStartThetaAngle()/degree ; 
    float deltaThetaAngle = solid->GetDeltaThetaAngle()/degree ; 

    // z to the right, theta   0 -> z=r, theta 180 -> z=-r
    float rTheta = startThetaAngle ;
    float lTheta = startThetaAngle + deltaThetaAngle ;
    assert( rTheta >= 0.f && rTheta <= 180.f) ; 
    assert( lTheta >= 0.f && lTheta <= 180.f) ; 

    bool zslice = startThetaAngle > 0.f || deltaThetaAngle < 180.f ; 
    LOG(info) 
              << " rTheta : " << rTheta
              << " lTheta : " << lTheta
              << " zslice : " << zslice
              ;

    float x = 0.f ; 
    float y = 0.f ; 
    float z = 0.f ; 

    nnode* cn = NULL ; 
    if(zslice)
    {
        float zmin = radius*std::cos(lTheta*CLHEP::pi/180.f) ;
        float zmax = radius*std::cos(rTheta*CLHEP::pi/180.f) ;
        assert( zmax > zmin ) ; 
        cn = new nzsphere(make_zsphere( x, y, z, radius, zmin, zmax )) ;
        cn->label = BStr::concat(m_name, "_nzsphere", NULL) ; 
    }
    else
    {
        cn = new nsphere(make_sphere( x, y, z, radius ));
        cn->label = BStr::concat(m_name, "_nsphere", NULL ) ; 
    }
    
    nnode* ret = has_inner ? new ndifference(make_difference(cn, inner)) : cn  ; 
    if(has_inner) ret->label = BStr::concat(m_name, "_ndifference", NULL ) ; 
  

    float startPhi = solid->GetStartPhiAngle()/degree ; 
    float deltaPhi = solid->GetDeltaPhiAngle()/degree ; 
    bool has_deltaPhi = deltaPhi < 360.f ; 
    assert( startPhi >= 0.f && !has_deltaPhi ); 

    // deltaphi_slab_segment_enabled is switched off in the python
    // so need some checking python side before porting

    return ret ; 
}



/**
X4Solid::convertSphere
========================

Following ../analytic/gdml.py results in different nnode primitive subclasses 
or small nnode CSG trees depending on parameter values.
    
::
    
    nsphere 
    nzsphere 
       zsliced
    ndifference  
       handling rmin > 0 
    nintersection  
       when applying a phi segment

**/
void X4Solid::convertSphere()
{  
    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    bool only_inner = false ; 
    nnode* n = convertSphere_(only_inner); 
    setRoot(n); 
}

void X4Solid::convertOrb()
{  
    const G4Orb* const solid = static_cast<const G4Orb*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    float radius = solid->GetRadius()/mm ; 

    float x = 0.f ; 
    float y = 0.f ; 
    float z = 0.f ; 

    nnode* n =  new nsphere(make_sphere( x, y, z, radius ));
    n->label = BStr::concat(m_name, "_sphere", NULL ) ; 
    setRoot(n); 
}


void X4Solid::convertBox()
{  
    // cf ../analytic/gdml.py:Box

    const G4Box* const solid = static_cast<const G4Box*>(m_solid);
    assert(solid); 

    //LOG(info) << "\n" << *solid ; 


    // match G4GDMLWriteSolids::BoxWrite
    float x = 2.0*solid->GetXHalfLength()/mm ; 
    float y = 2.0*solid->GetYHalfLength()/mm ; 
    float z = 2.0*solid->GetZHalfLength()/mm ; 

    nnode* n =  new nbox(make_box3( x, y, z));
    n->label = BStr::concat(m_name, "_box3", NULL ) ; 
    setRoot(n); 
}

void X4Solid::convertTubs()
{  
    // cf ../analytic/gdml.py:Tube

    const G4Tubs* const solid = static_cast<const G4Tubs*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    // match G4GDMLWriteSolids::TubeWrite

    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ; 
    float hz = solid->GetZHalfLength()/mm ;  
    float z = hz*2.0 ;   // <-- this full-length is what GDML stores
    float startPhi = solid->GetStartPhiAngle()/degree ; 
    float deltaPhi = solid->GetDeltaPhiAngle()/degree ; 

    bool has_inner = rmin > 0.f ; 
   
    nnode* inner = NULL ; 
    if(has_inner)
    {
        // Expand inner-z by 1%, note that this does not change geometry : 
        // as are expanding the inner tube in z which are about to subtract away.
        // This is a simple way of avoiding CSG coincident constituent surface glitches.

        float nudge_inner = 0.01f ; 
        float dz = hz*nudge_inner ;  
        inner = new ncylinder(make_cylinder(rmin, -(hz+dz), (hz+dz) )); 
        inner->label = BStr::concat( m_name, "_inner", NULL ); 
    }
    
    nnode* outer = new ncylinder(make_cylinder(rmax, -hz, hz));
    outer->label = BStr::concat( m_name, "_outer", NULL ); 

    nnode* tube = has_inner ? new ndifference(make_difference(outer, inner)) : outer ; 
    tube->label = BStr::concat( m_name, "_difference", NULL );

    bool deltaPhi_segment_enabled = true ; 
    bool has_deltaPhi = deltaPhi < 360.f ; 

    float segZ = z*1.01 ; 
    float segR = rmax*1.5 ;   

    // TODO: calculate what the segment prism segR size  should be rather 
    //       than this adhoc choice.
    //       As are intersecting it doesnt matter if the segR is too big, 
    //       but being too small could result in partial segmenting of the base shape
    //
    //       Is 50% bigger than rmax always a safe choice ?

    nnode* result =  has_deltaPhi && deltaPhi_segment_enabled 
                  ?
                     intersectWithPhiSegment(tube, startPhi, deltaPhi, segZ, segR ) 
                  :
                     tube 
                  ;

    setRoot(result); 
}


nnode* X4Solid::intersectWithPhiSegment(nnode* whole, float startPhi, float deltaPhi, float segZ, float segR )  
{
    bool has_deltaphi = deltaPhi < 360.f ; 
    assert( has_deltaphi ) ; 

    float phi0 = startPhi ; 
    float phi1 = startPhi + deltaPhi ; 

    nnode* segment = nconvexpolyhedron::make_segment(phi0, phi1, segZ, segR );  
    segment->label = BStr::concat(m_name, "_segment", NULL); 

    nnode* result = new nintersection(make_intersection(whole, segment)); 
    result->label = BStr::concat(m_name, "_intersection", NULL); 

    return result ;   
}

void X4Solid::convertTrd()
{  
/**
Following 

* G4GDMLWriteSolids::TrdWrite
* ../analytic/gdml.py 
* ../analytic/prism.py 

**/
    const G4Trd* const solid = static_cast<const G4Trd*>(m_solid);
    assert(solid); 

    float x1 = 2.0*solid->GetXHalfLength1()/mm ;
    float x2 = 2.0*solid->GetXHalfLength2()/mm ; 
    float y1 = 2.0*solid->GetYHalfLength1()/mm ; 
    float y2 = 2.0*solid->GetYHalfLength2()/mm ; 
    float z = 2.0*solid->GetZHalfLength()/mm ; 

    nnode* trd = nconvexpolyhedron::make_trapezoid(z, x1, y1, x2, y2 ); 
    trd->label = BStr::concat(m_name, "_solid", NULL ); 

    setRoot(trd); 
}


nnode* X4Solid::convertCons_(bool only_inner)
{
    const G4Cons* const cone = static_cast<const G4Cons*>(m_solid);
    assert(cone); 

    // G4GDMLWriteSolids::ConeWrite

    float rmax1    = cone->GetOuterRadiusMinusZ()/mm ;
    float rmax2    = cone->GetOuterRadiusPlusZ()/mm  ;

    float rmin1    = cone->GetInnerRadiusMinusZ()/mm ;
    float rmin2    = cone->GetInnerRadiusPlusZ()/mm  ;

    float z        = 2.0*cone->GetZHalfLength()/mm   ;
    float startPhi = cone->GetStartPhiAngle()/degree ;
    float deltaPhi = cone->GetDeltaPhiAngle()/degree ;

    bool has_inner = !only_inner && (rmin1 > 0.f || rmin2 > 0.f) ; 
    nnode* inner = has_inner ? convertCons_(true) : NULL ; 

    float r1 = only_inner ? rmin1 : rmax1 ; 
    float r2 = only_inner ? rmin2 : rmax2 ; 
    float z1 = -z/2.0 ; 
    float z2 = z/2.0 ; 

    nnode* cn = new ncone(make_cone(r1,z1,r2,z2)) ;
    cn->label = BStr::concat(m_name, "_cn", NULL ) ; 

    nnode* ret = has_inner ? new ndifference(make_difference(cn, inner)) : cn  ; 
    if(has_inner) ret->label = BStr::concat(m_name, "_ndifference", NULL ) ; 


    bool deltaPhi_segment_enabled = true ; 
    bool has_deltaPhi = deltaPhi < 360.f ; 

    float segZ = z*1.01 ; 
    float segR = std::max(rmax1, rmax2)*1.5 ;   

    // TODO: calculate what the segment prism segR size  should be rather 
    //       than this adhoc choice.
    //       As are intersecting it doesnt matter if the segR is too big, 
    //       but being too small could result in partial segmenting of the base shape
    //
    //       Is 50% bigger than rmax always a safe choice ?

    nnode* result =  has_deltaPhi && deltaPhi_segment_enabled 
                  ?
                     intersectWithPhiSegment(ret, startPhi, deltaPhi, segZ, segR ) 
                  :
                     ret 
                  ;

    return result ; 
}

void X4Solid::convertCons()
{  
    const G4Cons* const cone = static_cast<const G4Cons*>(m_solid);
    assert(cone); 
    LOG(info) << "\n" << *cone ; 

    bool only_inner = false ; 
    nnode* n = convertCons_(only_inner); 
    setRoot(n); 
}

void X4Solid::convertTorus()
{  
    const G4Torus* const solid = static_cast<const G4Torus*>(m_solid);
    assert(solid); 

    // G4GDMLWriteSolids::TorusWrite

    float rmin = solid->GetRmin()/mm ; 
    float rmax = solid->GetRmax()/mm ;
    float rtor = solid->GetRtor()/mm ;
    float startPhi = solid->GetSPhi()/degree ; 
    float deltaPhi = solid->GetDPhi()/degree ; 

    assert( rmin == 0.f ); // torus with rmin not yet handled 
    assert( startPhi == 0.f && deltaPhi == 360.f ); 

    float r = rmax ; 
    float R = rtor ; 
    assert( R > r ); 

    nnode* n = new ntorus(make_torus(R, r)) ;
    n->label = BStr::concat( m_name , "_torus" , NULL ); 
    setRoot(n); 
}

void X4Solid::convertEllipsoid()
{  
    const G4Ellipsoid* const solid = static_cast<const G4Ellipsoid*>(m_solid);
    assert(solid); 

    // G4GDMLWriteSolids::EllipsoidWrite

    float ax = solid->GetSemiAxisMax(0)/mm ; 
    float by = solid->GetSemiAxisMax(1)/mm ; 
    float cz = solid->GetSemiAxisMax(2)/mm ; 

    glm::vec3 scale( ax/cz, by/cz, 1.f) ;   
    // unity scaling in z, so z-coords are unaffected  
 
    float zcut1 = solid->GetZBottomCut()/mm ; 
    float zcut2 = solid->GetZTopCut()/mm ;

    float z1 = zcut1 != 0.f && zcut1 > -cz ? zcut1 : -cz ; 
    float z2 = zcut2 != 0.f && zcut2 <  cz ? zcut2 :  cz ; 
    assert( z2 > z1 ) ;  

    bool zslice = z1 > -cz || z2 < cz ;  

    nnode* cn = zslice ? 
                          (nnode*)new nzsphere(make_zsphere( 0.f, 0.f, 0.f, cz, z1, z2 )) 
                       :
                          (nnode*)new nsphere(make_sphere( 0.f, 0.f, 0.f, cz )) 
                       ;

    cn->label = BStr::concat(m_name, "_ellipsoid", NULL) ; 
    cn->transform = nmat4triple::make_scale( scale );
    
    LOG(info) 
         << std::endl  
         << gpresent("tr.t", cn->transform->t ) 
         << std::endl  
         << gpresent("tr.v", cn->transform->v )  
         << std::endl  
         << gpresent("tr.q", cn->transform->q ) 
         << std::endl  
         ;

    setRoot(cn); 
}


void X4Solid::convertPolyconePrimitives( const std::vector<zplane>& zp,  std::vector<nnode*>& prims )
{
    for( unsigned i=1 ; i < zp.size() ; i++ )
    {
        const zplane& zp1 = zp[i-1] ; 
        const zplane& zp2 = zp[i] ; 
        double r1 = zp1.rmax ; 
        double r2 = zp2.rmax ; 
        double z1 = zp1.z ; 
        double z2 = zp2.z ; 

        if( z1 == z2 )
        {
            LOG(warning) << " skipping z2 == z1 zp " ; 
            continue ; 
        }
        
        bool z_ascending = z2 > z1 ; 
        if(!z_ascending) LOG(fatal) << " !z_ascending " 
                                    << " z1 " << z1  
                                    << " z2 " << z2
                                    ;  
        assert(z_ascending); 

        nnode* n = NULL ; 
        if( r2 == r1 )
        { 
            n = new ncylinder(make_cylinder(r2, z1, z2));
            n->label = BStr::concat( m_name, i-1, "_zp_cylinder" ); 
        }
        else
        {
            n = new ncone(make_cone(r1,z1,r2,z2)) ;
            n->label = BStr::concat<unsigned>(m_name, i-1 , "_zp_cone" ) ; 
        }
        prims.push_back(n); 
    }   // over pairs of planes
}


void X4Solid::convertPolycone()
{  
    // G4GDMLWriteSolids::PolyconeWrite
    // G4GDMLWriteSolids::ZplaneWrite
    // ../analytic/gdml.py 

    const G4Polycone* const solid = static_cast<const G4Polycone*>(m_solid);
    assert(solid); 
    const G4PolyconeHistorical* ph = solid->GetOriginalParameters() ;

    float startphi = ph->Start_angle/degree ;  
    float deltaphi = ph->Opening_angle/degree ;
    assert( startphi == 0.f && deltaphi == 360.f ); 

    std::vector<zplane> zp(ph->Num_z_planes) ; 

    std::set<double> Rmin ; 
    unsigned nz = ph->Num_z_planes ; 

    for (int i=0; i < nz ; i++) 
    {
        zp[i] = { ph->Rmin[i], ph->Rmax[i], ph->Z_values[i] } ;  
        Rmin.insert( ph->Rmin[i] );
    }

    if( zp.size() == 2 && zp[0].z > zp[0].z )
    {
        LOG(warning) << "Polycone swap misordered pair of zplanes for " << m_name ; 
        std::reverse( std::begin(zp), std::end(zp) ) ; 
    }

    std::vector<nnode*> prims ; 
    convertPolyconePrimitives( zp, prims ); 
    nnode* cn = NTreeBuilder<nnode>::UnionTree(prims) ;


    bool multi_Rmin = Rmin.size() > 1 ; 
    if( multi_Rmin ) 
    {
        LOG(fatal) << " multiple Rmin is unhandled " << m_name ;  
    }
    assert( !multi_Rmin ) ; 

    double rmin = *Rmin.begin() ; 
    bool has_inner = rmin > 0. ; 

    nnode* inner = NULL ; 
    if(has_inner)
    {
        double zmin = zp[0].z ; 
        double zmax = zp[nz-1].z ; 
        inner = new ncylinder(make_cylinder(rmin, zmin, zmax));
        inner->label = BStr::concat( m_name, "_inner_cylinder", NULL  ); 
    }

    nnode* result = inner ? new ndifference(make_difference( cn, inner ))  : cn ; 
    setRoot(result); 
}



void X4Solid::convertHype()
{  
    const G4Hype* const solid = static_cast<const G4Hype*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    bool only_inner = false ; 
    nnode* n = convertHype_(only_inner); 
    setRoot(n); 
}

nnode* X4Solid::convertHype_(bool only_inner)
{
    const G4Hype* const solid = static_cast<const G4Hype*>(m_solid);

    // G4GDMLWriteSolids::HypeWrite
    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ;
    float inst = solid->GetInnerStereo()/degree ; 
    float outst = solid->GetOuterStereo()/degree ;
    float z = 2.0*solid->GetZHalfLength()/mm ; 

    bool has_inner = !only_inner && rmin > 0.f ; 

    nnode* inner = has_inner ? convertHype_(true) : NULL ;  

    float radius = only_inner ? rmin : rmax ;   
    float stereo = only_inner ? inst : outst ; 

    /*
     Opticks CSG_HYPERBOLOID uses
                x^2 +  y^2  =  r0^2 * (  (z/zf)^2  +  1 )

     G4Hype uses
                x^2 + y^2 = (z*tanphi)^2 + r^2
                x^2 + y^2 =  r0^2 * ( (z*tanphi/r0)^2 + 1 )

     So     
               tanphi/r0 = 1/zf

               zf = r0/tanphi
    */

    float zf = radius/std::tan(stereo*CLHEP::pi/180.) ;
    float z2 =  z/2.0 ; 
    float z1 = -z/2.0 ;
 
    nnode* cn = new nhyperboloid(make_hyperboloid( radius, zf, z1, z2 ));
    cn->label = BStr::concat(m_name, "_hyperboloid", NULL ) ; 
    
    nnode* result = inner ? new ndifference(make_difference( cn, inner ))  : cn ; 
    return result ; 
}


